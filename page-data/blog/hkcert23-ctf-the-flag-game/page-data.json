{"componentChunkName":"component---src-pages-blog-strapi-article-slug-tsx","path":"/blog/hkcert23-ctf-the-flag-game/","result":{"data":{"allStrapiArticle":{"nodes":[{"id":"224cab6e-d942-5e1c-880d-4fb4628cfe24","slug":"hkcert23-ctf-the-flag-game","title":"HKCERT23 CTF - The Flag Game (200)","description":"https://ctftime.org/event/2122","content":{"data":{"content":"# Writeup\n![the-flag-game-screenshot](https://www.cms.void-dojo.ninja/uploads/Screenshot_2023_12_13_at_02_13_40_The_Flag_Game_2b47882f2e.png)\n\nThis challenge imitate [The Password Game](https://neal.fun/password-game/). We need to find out the flag by fulfilling set of rules, like:\n- The flag must not include character 'f', 'l', 'a', 'g'.\n- Your flag must start with hkcert23.\n- Your flag must include exactly one { and one }.   \n   \nand more...\n\\\n\\\nAfter spending hour and hour to play the flag game...we stuck on rule 27... it's too difficult. We also found that after rule 27 the description are all obfuscated... not readable:\n![the-flag-game-obfuscate.png](https://www.cms.void-dojo.ninja/uploads/the_flag_game_obfuscate_747851f8c1.png)\n\nIt must be another method to get the flag. Let's checkout the source code.   \nYou can view the source code here: [https://github.com/blackb6a/hkcert-ctf-2023-challenges/tree/master/01-the-flag-game](https://github.com/blackb6a/hkcert-ctf-2023-challenges/tree/master/01-the-flag-game)\n\n\n## The Hash\nFrom the image above, we also see there is an checker function for each rules. After rule 27, the checker function will do `SHA256` or `SHA224` hash validation (using `startWith()`) from user input. Since those rule with hash validation are not in order of flag character sequences. Why? Suspect the code `e => f(...)` the `e` should be the full flag string,    \n```txt\nsha224(e.substr(0, 8)) = sha224('hkcert23') = b08c896f048ffc60ea98da02526f64ddedf0ba7953a4b24d69c45644. \n```\nHence we know that position `0-8` is the beginning of entire flag... and rest of the checker function it offset the substr ending position by +2, so we suspect in each rule after rule 27 it give the hash of the flag. Ha, we have chance to brute forcing the original flag by using these information!   \n![the-flag-game-obfuscate-3.png](https://www.cms.void-dojo.ninja/uploads/the_flag_game_obfuscate_3_3b64edfcc2.png)\nNow we know that the checker function is checking the entire flag. We can skip the first one because we already know the flag is start with `hkcert23`. Also prepare a map for brute forcing sort by the substr end position:\n![the-flag-game-obfuscate-2.png](https://www.cms.void-dojo.ninja/uploads/the_flag_game_obfuscate_2_f9fc5fdd43.png)\n\n\n## Solve\nIn the solving script, use `hashlib` for handling `sha256` `sha224` hashing. I decide to try 1 or 2 characters for each rule... most of the case guessing on 2 characters combination should get the matching hash value, but you see the last several of rules (38, 42), the hash value is the same! So it may representing 1 or even 3 new characters for those hash value of last rules.\n```python:solve.py\nimport hashlib\n\nHASH_CHECKS = [\n    {\n        \"length\": 10,\n        \"hash_method\": 'sha224',\n        \"hash_value\": \"ce45fd\",\n    },\n    {\n        \"length\": 12,\n        \"hash_method\": 'sha256',\n        \"hash_value\": \"87b3c7\",\n    },\n    {\n        \"length\": 14,\n        \"hash_method\": 'sha256',\n        \"hash_value\": \"d0687a\",\n    },\n    {\n        \"length\": 16,\n        \"hash_method\": 'sha256',\n        \"hash_value\": \"cbe2c9\",\n    },\n    {\n        \"length\": 18,\n        \"hash_method\": 'sha256',\n        \"hash_value\": \"c25dd2\",\n    },\n    {\n        \"length\": 20,\n        \"hash_method\": 'sha256',\n        \"hash_value\": \"b72709\",\n    },\n    {\n        \"length\": 22,\n        \"hash_method\": 'sha224',\n        \"hash_value\": \"8b035b\",\n    },\n    {\n        \"length\": 24,\n        \"hash_method\": 'sha256',\n        \"hash_value\": \"40f34c\",\n    },\n    {\n        \"length\": 26,\n        \"hash_method\": 'sha256',\n        \"hash_value\": \"7be965\",\n    },\n    {\n        \"length\": 28,\n        \"hash_method\": 'sha224',\n        \"hash_value\": \"0b67cb\",\n    },\n    {\n        \"length\": 30,\n        \"hash_method\": 'sha224',\n        \"hash_value\": \"bf7eeb\",\n    },\n    {\n        \"length\": 32,\n        \"hash_method\": 'sha256',\n        \"hash_value\": \"f9f48b\",\n    },\n    {\n        \"length\": 34,\n        \"hash_method\": 'sha224',\n        \"hash_value\": \"69260f\",\n    },\n    {\n        \"length\": 36,\n        \"hash_method\": 'sha256',\n        \"hash_value\": \"7ef31a\",\n    },\n    {\n        \"length\": 38,\n        \"hash_method\": 'sha256',\n        \"hash_value\": \"e3c817\",\n    },\n    {\n        \"length\": 40,\n        \"hash_method\": 'sha224',\n        \"hash_value\": \"8a9de8\",\n    },\n    {\n        \"length\": 42,\n        \"hash_method\": 'sha256',\n        \"hash_value\": \"e3c817\",\n    },\n]\n\nFLAG_START = \"hkcert23\"\nCHARSET = \"0123456789bcdeghjkmnopqrstuvwxyz{}_\"\n\ndef check_hash(hash_check, flag):\n    hash_method = hash_check[\"hash_method\"]\n    hash_value = hash_check[\"hash_value\"]\n    length = hash_check[\"length\"]\n    string_subset = flag[:length]\n    if hash_method == 'sha256':\n        return hashlib.sha256(string_subset.encode()).hexdigest().startswith(hash_value)\n    return hashlib.sha224(string_subset.encode()).hexdigest().startswith(hash_value)\n\n\ndef main():\n    flag = FLAG_START\n    for hash_check in HASH_CHECKS:\n        print(f\"Brute forcing for position {hash_check['length']}\")\n        is_found = False\n        # Try guessing 2 chars first, otherwise try 1 char\n        for chars_to_guess in [2, 1]:\n            if is_found:\n                break\n            if chars_to_guess == 1:\n                for char in CHARSET:\n                    flag_to_check = flag + char\n                    if check_hash(hash_check, flag_to_check):\n                        flag = flag_to_check\n                        is_found = True\n                        print(f\"üéâ Found! {flag}\" )\n                        break\n                else:\n                    print(f\"‚ùå Not found for 1 char\")\n            elif chars_to_guess == 2:\n                for char1 in CHARSET:\n                    for char2 in CHARSET:\n                        flag_to_check = flag + char1 + char2\n                        if check_hash(hash_check, flag_to_check):\n                            flag = flag_to_check\n                            print(f\"üéâ Found! {flag}\" )\n                            is_found = True\n                            break\n                    if is_found:\n                        break\n                else:\n                    print(f\"‚ùå Not found for 2 chars\")\n    print(f\"flag `{flag}`\")\n\n\nif __name__ == '__main__':\n    main()\n```\nOutput\n```bash\n‚ô•  python .\\solve.py\nBrute forcing for position 10\nüéâ Found! hkcert23{h\nBrute forcing for position 12\nüéâ Found! hkcert23{h0p\nBrute forcing for position 14\nüéâ Found! hkcert23{h0p3_\nBrute forcing for position 16\nüéâ Found! hkcert23{h0p3_y0\nBrute forcing for position 18\nüéâ Found! hkcert23{h0p3_y0u_\nBrute forcing for position 20\nüéâ Found! hkcert23{h0p3_y0u_u5\nBrute forcing for position 22\nüéâ Found! hkcert23{h0p3_y0u_u53d\nBrute forcing for position 24\nüéâ Found! hkcert23{h0p3_y0u_u53d_t\nBrute forcing for position 26\nüéâ Found! hkcert23{h0p3_y0u_u53d_th3\nBrute forcing for position 28\nüéâ Found! hkcert23{h0p3_y0u_u53d_th3_s\nBrute forcing for position 30\nüéâ Found! hkcert23{h0p3_y0u_u53d_th3_s0u\nBrute forcing for position 32\nüéâ Found! hkcert23{h0p3_y0u_u53d_th3_s0urc\nBrute forcing for position 34\nüéâ Found! hkcert23{h0p3_y0u_u53d_th3_s0urc3m\nBrute forcing for position 36\nüéâ Found! hkcert23{h0p3_y0u_u53d_th3_s0urc3m4p\nBrute forcing for position 38\n‚ùå Not found for 2 chars\nüéâ Found! hkcert23{h0p3_y0u_u53d_th3_s0urc3m4p}\nBrute forcing for position 40\n‚ùå Not found for 2 chars\n‚ùå Not found for 1 char\nBrute forcing for position 42\n‚ùå Not found for 2 chars\n‚ùå Not found for 1 char\nflag `hkcert23{h0p3_y0u_u53d_th3_s0urc3m4p}`\n```\nflag `hkcert23{h0p3_y0u_u53d_th3_s0urc3m4p}`"}},"updatedAt":"2023-12-12T18:54:36.774Z","publishedAt":"2023-12-12T17:56:32.545Z","tags":[{"name":"reverse","color":"orange"},{"name":"hkcertctf","color":"yellow"}],"categories":[{"name":"ctf","color":"red"}],"cover":{"formats":{"thumbnail":{"url":"/uploads/thumbnail_hkcert23_banner_0e9291d451.png"},"small":null}}}]}},"pageContext":{"id":"224cab6e-d942-5e1c-880d-4fb4628cfe24","slug":"hkcert23-ctf-the-flag-game","__params":{"slug":"hkcert23-ctf-the-flag-game"}}},"staticQueryHashes":["3001278788"],"slicesMap":{}}