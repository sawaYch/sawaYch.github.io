{"componentChunkName":"component---src-pages-blog-strapi-article-slug-tsx","path":"/blog/hkcert23-ctf-bades/","result":{"data":{"allStrapiArticle":{"nodes":[{"id":"f9012296-1dc2-576c-afcd-9fde4e3e7b3b","slug":"hkcert23-ctf-bades","title":"HKCERT23 CTF - baDES (200)","description":"https://ctftime.org/event/2122","content":{"data":{"content":"# Writeup\nThis challenge provide [step by step guideline](https://hackmd.io/@blackb6a/hkcert-ctf-2023-ii-en-4e6150a89a1ff32c#%E4%B8%8B%E6%89%8B%E3%81%A7%E3%81%99%E3%81%AD--BADES-Crypto)   \n\\\nTo get the flag, we need to find plaintext from customized DES' CBC encryption. The challenge provide a website give us two oracle calls:\n1. get encrypted flag hex string\n2. do encryption of hex string\n\nFirst we can get the full encrypted flag by oracle call (1). Then we split the flag data into 8 bytes:\n```python\n# suppose flag is hex string, 2 characters (i.e. FF) is a byte, so 8 bytes = `16` characters\nc = [int(flag[i:i + 16], 16) for i in range(0, len(flag), 16)]\n```\n\n\nFrom the guideline given we can retrieve the first plaintext block (m1) by computing the followings:\n1. Calculate `c0 ^ c1` = `0x1782990b2061bbee`\n2. Encrypt(`c0^c1`) = `0x696e697469616c76 01050a111b155e45 09230926dc97675e`\n3. Select second last block as `m1^c0` => `0x01050a111b155e45`\n4. `m1` = (`m1^c0`)^`c0` => `0x686b636572743233`\n5. decode hex string to ASCII `hkcert23`\n\nTo find m2:\n1. Calculate `c0 ^ c2` = `0xa4f0b2e1c4df4768`\n2. Encrypt(`c0^c2`) = `m2^c1` => `0x696e697469616c76 05a8b52c1663e3f6 b87d1d6f13d55785`\n3. Select second last block as `m2^c1` => `0x05a8b52c1663e3f6`\n4. `m2` = (`m2^c1`)^`c1` => `0x7b4445535f63346e`\n5. decode hex string ASCII `{DES_c4n`\n\\\n\\\n`\nðŸš€ Note: This solution has been deduced to be simplified\n`\n\\\n\\\nHere is the local version of solve program which simulate the encryption oracle function by using `pydes.py` & `cipher.py`, these 2 files are given:\n```python\n# This program is modified local version to illustrate how bades works\n# The original solving script use remote request encryption to get the encrypted flag result\nfrom Crypto.Util.Padding import pad\nfrom pydes import des, CBC\n\n# Copied from cipher.py, sync the changes\n# Now, I am changing `__left_rotations` to something sussy :)\n# What will happen?\ndes._des__left_rotations = \\\n    [16, 25, 8, 1, 7, 13, 3, 4, 0, 24, 25, 15, 21, 27, 20, 3]\n\n# define key and iv, simulate challenge server's setup \nkey = b'secret_k'\niv = b'initialv'\n\n\"\"\" \nModified encrypt() from cipher.py\n\n@param message: the hex string of message (e.g. ff12ffe0)\n@return: bytes object of encrypted cipher text\n\"\"\" \ndef encrypt(message: str):\n    # In this challenge, the `key` and `iv` sent to the function are fixed.\n    # message is the input defined by the player if \"encrypt message\" is used,\n    # or the flag if \"encrypt flag\" is used.\n    #\n    # Concretely,\n    # - `/encrypt/?m=68656c6c6f` would call `encrypt(b'hello', key, iv)` since\n    #   \"68656c6c6f\" is the hex-encoded \"hello\" and\n    # - `/encrypt/flag/` would call `encrypt(flag, key, iv)`.\n    cipher = des(key=key, mode=CBC, IV=iv)\n    plaintext = pad(bytes.fromhex(message), 8)\n    # encrypt_result = cipher.encrypt(plaintext)\n    cipher_text = iv + cipher.encrypt(plaintext)\n    return cipher_text\n\n\n\"\"\"\nCBC block = 8 byte\nwe need to padding our flag hex string length to multiple of 16, e.g.\n686b636572743233\n7b4445535f63346e\n5f36655f33347331\n6c795f6430776e67\n72346433645f3679\n5f6368346e673331\n6e675f6c31743731\n655f7468316e3973\n7d00000000000000\n\"\"\"\ndef pad_cbc_block(cipher_flag):\n    length = len(cipher_flag)\n    if length % 16 == 0:\n        return cipher_flag\n    else:\n        padding = 16 - (length % 16)\n        print('padding', padding)\n        return cipher_flag + '0'* padding\n    \n# encrypt the flag, simulate what chall server do\ncipher_flag = encrypt(b\"hkcert23{DES_c4n_6e_34s1ly_d0wngr4d3d_6y_ch4ng31ng_l1t71e_th1n9s}\".hex())\nflag = pad_cbc_block(cipher_flag.hex())\n\n# Each 8 bytes is a block, and it's in hex so we make it back into ints so we can work with it\nc = [int(flag[i:i + 16], 16) for i in range(0, len(flag), 16)]\nc_hex = ''.join(map(lambda x: x.to_bytes(8, 'big').hex() + ' | ', c))\n\nprint('flag (hex string)', flag, '\\nblocks (hex string)', c_hex, '\\n')\n\nm = []\nfor i in range(1, len(c)):\n    print(f'iteration {i}:')\n    print(f'c0^c{i} : 0x{c[0].to_bytes(8, \"big\").hex()} ^ 0x{c[i].to_bytes(8, \"big\").hex()} = 0x{(c[0]^c[i]).to_bytes(8, \"big\").hex()}')\n    ciXc0 = (c[0] ^ c[i]).to_bytes(8, 'big').hex()\n    miXci_1 = encrypt(ciXc0).hex() # simulate remote oracle call encryption\n    print(f'encrypt(c0^c{i}) = m{i}^c{i-1} = 0x{miXci_1}')\n    miXci_1 = miXci_1[16:32]\n    print(f'm{i} = (m{i}^c{i-1}) ^ c{i-1} = 0x{int(miXci_1, 16).to_bytes(8, \"big\").hex()} ^ 0x{c[i-1].to_bytes(8,\"big\").hex()} = 0x{(int(miXci_1, 16) ^ c[i-1]).to_bytes(8,\"big\").hex()}')\n    m_i = (int(miXci_1, 16) ^ c[i-1]).to_bytes(8, 'big')\n    print(f'm{i} [{m_i}]\\n')\n    m.append(m_i)\n\nprint(''.join(map(lambda x: x.decode(), m)))\n```\n\\\nOutput:\n```bash\ncipher flag (hex string) 696e697469616c767eecf07f4900d798cd9edb95adbe2b1e619475510775c85da637d5d849dae4574a70a996fed788303855dd1832ac8dd7f4c848de9f3b0aa110e64ce89ccbc4acd0923e5946d1261c\nblocks (hex string) 696e697469616c76 | 7eecf07f4900d798 | cd9edb95adbe2b1e | 619475510775c85d | a637d5d849dae457 | 4a70a996fed78830 | 3855dd1832ac8dd7 | f4c848de9f3b0aa1 | 10e64ce89ccbc4ac | d0923e5946d1261c |\n\niteration 1:\nc0^c1 : 0x696e697469616c76 ^ 0x7eecf07f4900d798 = 0x1782990b2061bbee\nencrypt(c0^c1) = m1^c0 = 0x696e697469616c7601050a111b155e4509230926dc97675e\nm1 = (m1^c0) ^ c0 = 0x01050a111b155e45 ^ 0x696e697469616c76 = 0x686b636572743233\nm1 [b'hkcert23']\n\niteration 2:\nc0^c2 : 0x696e697469616c76 ^ 0xcd9edb95adbe2b1e = 0xa4f0b2e1c4df4768\nencrypt(c0^c2) = m2^c1 = 0x696e697469616c7605a8b52c1663e3f6b87d1d6f13d55785\nm2 = (m2^c1) ^ c1 = 0x05a8b52c1663e3f6 ^ 0x7eecf07f4900d798 = 0x7b4445535f63346e\nm2 [b'{DES_c4n']\n\niteration 3:\nc0^c3 : 0x696e697469616c76 ^ 0x619475510775c85d = 0x08fa1c256e14a42b\nencrypt(c0^c3) = m3^c2 = 0x696e697469616c7692a8beca9e8a582f147edddb106402cc\nm3 = (m3^c2) ^ c2 = 0x92a8beca9e8a582f ^ 0xcd9edb95adbe2b1e = 0x5f36655f33347331\nm3 [b'_6e_34s1']\n\niteration 4:\nc0^c4 : 0x696e697469616c76 ^ 0xa637d5d849dae457 = 0xcf59bcac20bb8821\nencrypt(c0^c4) = m4^c3 = 0x696e697469616c760ded2a353702a63aa648d8b172c7a1ea\nm4 = (m4^c3) ^ c3 = 0x0ded2a353702a63a ^ 0x619475510775c85d = 0x6c795f6430776e67\nm4 [b'ly_d0wng']\n\niteration 5:\nc0^c5 : 0x696e697469616c76 ^ 0x4a70a996fed78830 = 0x231ec0e297b6e446\nencrypt(c0^c5) = m5^c4 = 0x696e697469616c76d403b1eb2d85d22e6f134b0b3a90041f\nm5 = (m5^c4) ^ c4 = 0xd403b1eb2d85d22e ^ 0xa637d5d849dae457 = 0x72346433645f3679\nm5 [b'r4d3d_6y']\n\niteration 6:\nc0^c6 : 0x696e697469616c76 ^ 0x3855dd1832ac8dd7 = 0x513bb46c5bcde1a1\nencrypt(c0^c6) = m6^c5 = 0x696e697469616c761513c1a290b0bb01410326aae026b48f\nm6 = (m6^c5) ^ c5 = 0x1513c1a290b0bb01 ^ 0x4a70a996fed78830 = 0x5f6368346e673331\nm6 [b'_ch4ng31']\n\niteration 7:\nc0^c7 : 0x696e697469616c76 ^ 0xf4c848de9f3b0aa1 = 0x9da621aaf65a66d7\nencrypt(c0^c7) = m7^c6 = 0x696e697469616c765632827403d8bae6d09d4c484b3be730\nm7 = (m7^c6) ^ c6 = 0x5632827403d8bae6 ^ 0x3855dd1832ac8dd7 = 0x6e675f6c31743731\nm7 [b'ng_l1t71']\n\niteration 8:\nc0^c8 : 0x696e697469616c76 ^ 0x10e64ce89ccbc4ac = 0x7988259cf5aaa8da\nencrypt(c0^c8) = m8^c7 = 0x696e697469616c7691973cb6ae5533d2a842df0da4814776\nm8 = (m8^c7) ^ c7 = 0x91973cb6ae5533d2 ^ 0xf4c848de9f3b0aa1 = 0x655f7468316e3973\nm8 [b'e_th1n9s']\n\niteration 9:\nc0^c9 : 0x696e697469616c76 ^ 0xd0923e5946d1261c = 0xb9fc572d2fb04a6a\nencrypt(c0^c9) = m9^c8 = 0x696e697469616c766de14bef9bccc3ab0faa3d420cdbc5de\nm9 = (m9^c8) ^ c8 = 0x6de14bef9bccc3ab ^ 0x10e64ce89ccbc4ac = 0x7d07070707070707\nm9 [b'}\\x07\\x07\\x07\\x07\\x07\\x07\\x07']\n\nhkcert23{DES_c4n_6e_34s1ly_d0wngr4d3d_6y_ch4ng31ng_l1t71e_th1n9s}\n```\n\nflag: `hkcert23{DES_c4n_6e_34s1ly_d0wngr4d3d_6y_ch4ng31ng_l1t71e_th1n9s}`\n\n# Basic approach\nThis solution is more easy to understand theoretically. [https://hackmd.io/@happypotato1207/HKCERT_CTF_2023_baDES](https://hackmd.io/@happypotato1207/HKCERT_CTF_2023_baDES)\n\\\nThe solving steps basically are the same as above solution, the only differences are:\n1. For the first step, do calculation `ci^ci-1` instead of `c0^ci`\n2. For second step encryption need to concat previous plaintext as function argument    \ni.e. `Encrypt(m0 || m1 || m2 || ... || mi-1 || ci^ci-1)`  instead of `Encrypt(c0^ci)`; \n\n```python\nfor i in range(1, len(c)):\n    ciXc0 = (c[i-1] ^ c[i]).to_bytes(8, 'big').hex()\n    past_m = ''.join(map(lambda x: x.hex(), m))\n    miXci_1 = encrypt(past_m+ciXc0).hex() # simulate remote oracle call encryption\n    miXci_1 = miXci_1[16*i:-16] #[16:32]\n    m_i = (int(miXci_1, 16) ^ c[i-1]).to_bytes(8, 'big')\n    m.append(m_i)\n\nprint(''.join(map(lambda x: x.decode(), m)))\n```"}},"updatedAt":"2023-12-10T19:26:07.057Z","publishedAt":"2023-12-10T18:26:15.445Z","tags":[{"name":"crypto","color":"teal"},{"name":"hkcertctf","color":"yellow"}],"categories":[{"name":"ctf","color":"red"}],"cover":{"formats":{"thumbnail":{"url":"/uploads/thumbnail_hkcert23_banner_0e9291d451.png"},"small":null}}}]}},"pageContext":{"id":"f9012296-1dc2-576c-afcd-9fde4e3e7b3b","slug":"hkcert23-ctf-bades","__params":{"slug":"hkcert23-ctf-bades"}}},"staticQueryHashes":["3001278788"],"slicesMap":{}}