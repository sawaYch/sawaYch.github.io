{"componentChunkName":"component---src-pages-blog-strapi-article-slug-tsx","path":"/blog/hkcert23-ctf-sign-me-a-flag/","result":{"data":{"allStrapiArticle":{"nodes":[{"id":"b089d5f4-585b-5ffb-8dfb-f7f6f3d9df4e","slug":"hkcert23-ctf-sign-me-a-flag","title":"HKCERT23 CTF - Sign me a flag I (150)","description":"https://ctftime.org/event/2122\n","content":{"data":{"content":"# Challenge\nThis challenge with step by step [guideline](https://hackmd.io/@blackb6a/hkcert-ctf-2023-i-en-a58d115f39feab46#%E6%B1%82%E6%97%97%E7%B0%BD%E5%90%8D-I--Sign-me-a-Flag-I-Crypto)   \nsource code [here](https://gist.github.com/sawaYch/cfcdacd153fb5230a31541c1450df6aa)\n\\\nAs mention by the guideline, the server provide 2 features:\n1. signature = sign(client_key, message)   \n    create a signature by input client key and message, server will do HMAC-SHA256(client_key ^ server_key, message) and return the signature\n2. verify(signature)   \n    for getting flag, by input message = 'gib flag pls' and correct 'signature' that fulfill HMAC-SHA256(0x0000000000000000 ^ server_key, message). Notice that the client key is fixed to 16 bytes zero here, so for the rest of our work need to keep consistent on it.   \n    \n## Leaking byte by byte\nOur target is use feature (1) to retrieve the server_key, hence using feature (2) to get the flag. Here is how to use feature (1) attack server to leak the server_key (summarized from the guideline):\n\nGiven we have 2 signing function, 1 is remote oracle call:   \n`remote_sign(client_key, message)`   \nanother one is local signing function:   \n`local_sign(client_key, server_key, message)`    \nwhere the signing implementation are the same of these 2 function, the only difference is that one for making remote oracle call `feature 1 sign (server_key is unknown)`, another one is local computation for guessing server_key for the attack.   \n\\\n0. remember that 1 byte = 8 bit =1111 1111 (binary) = 0xFF (hex)\n1. hack on first byte, oracle call to server: `s_1` = remote_sign(0x00, 'anystring')   \n2. brute force 0x01 to 0xFF for guessing server_key on local:   \nlocal_sign(0x00, 0x00, 'anystring')   \nlocal_sign(0x00, 0x01, 'anystring')   \nlocal_sign(0x00, 0x02, 'anystring')   \n...   \nlocal_sign(0x00, 0xFF, 'anystring')\neventually find local_sign(0x00, `u_1`, 'anystring') that is equal to `s_1`, hence the first byte of server_key would be `u_1`   \n3. continue to get second byte of server_key, compute `s_2` = remote_sign(0x0000, 'anystring'), then trial:   \nlocal_sign(0x0000, u_1 || 0x00, 'anystring')   \nlocal_sign(0x0000, u_1 || 0x01, 'anystring')   \nlocal_sign(0x0000, u_1 || 0x02, 'anystring')   \n...   \nlocal_sign(0x0000, u_1 || 0xFF, 'anystring')   \neventually we will find local_sign(0x0000, `u_1` || `u_2`, 'anystring') that is equal to `s_2`, hence the second byte of server_key would be `u_2`\n\nThe solve program is provided, but it spent too much trial of oracle calls to leak the server_key (take 16 times; the server key is total 16 bytes). Our task is to modify the program to make the number of oracle calls <= 10 calls.    \nThe original solve.py:\n```python\n...\n...\nif __name__ == '__main__':\n    r = remote('chal.hkcert23.pwnable.hk', 28029)\n\n    key_server = b''\n\n    for i in range(16):\n        s = sign(r, b'\\0'*(i+1), 'testing')\n\n        for guess in range(256):\n            key_server_guess = key_server + int.to_bytes(guess, 1, 'big')\n            if sign_message(b'\\0'*(i+1), key_server_guess, 'testing') != s: continue\n            key_server = key_server_guess\n            break\n        print(f'{key_server = }')\n    \n    get_flag(r, key_server)\n\n    r.interactive()\n```\nEach time we need 1 oracle call to get 1 byte correct server_key from remote server, total spent 16 times oracle call, which exceed the limitation.\n\n## Leaking every 2 bytes, reduce oracle calls\nThe modified version:\n```python\n...\n...\nif __name__ == '__main__':\n    r = remote('chal.hkcert23.pwnable.hk', 28029)\n    key_server = b''\n    for i in range(8): # change 1\n        s = sign(r, b'\\0' * (i+1) * 2, 'testing') # change 2\n        for guess in range(256*256):\n            key_server_guess = key_server + int.to_bytes(guess, 2, 'big') # change 3\n            if sign_message(b'\\0'*(i+1) * 2, key_server_guess, 'testing') != s: continue # change 4\n            key_server = key_server_guess\n            break\n        print(f'{key_server = }')\n    \n    get_flag(r, key_server)\n    r.interactive()\n```\nThese changes let us get 2 correct bytes of server key for each oracle call from server, each call we request 2 bytes and the oracle calls can reduce by half from `16` -> `8` (change 1).   \n\\\nAlso, the local trial will growth exponentially. Like brute forcing the password combination, let say for 1 digit we need x times, then for 2 digit we need x^2 times; so here we need 256^2 = 256 * 256 (change 2).   \n\\\nFor change 3 & 4 is the code changes to handle 2 byte computation for the signature signing.   \n\\\n\\\nflag: `hkcert23{l34k1n9_th3_k3y_b1t_6y_bi7_1s_fun}`"}},"updatedAt":"2023-12-07T01:34:44.097Z","publishedAt":"2023-12-06T07:16:33.401Z","tags":[{"name":"crypto","color":"teal"},{"name":"hkcertctf","color":"yellow"}],"categories":[{"name":"ctf","color":"red"}],"cover":{"formats":{"thumbnail":{"url":"/uploads/thumbnail_hkcert23_banner_0e9291d451.png"},"small":null}}}]}},"pageContext":{"id":"b089d5f4-585b-5ffb-8dfb-f7f6f3d9df4e","slug":"hkcert23-ctf-sign-me-a-flag","__params":{"slug":"hkcert23-ctf-sign-me-a-flag"}}},"staticQueryHashes":["3001278788"],"slicesMap":{}}