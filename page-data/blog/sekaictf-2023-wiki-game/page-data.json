{"componentChunkName":"component---src-pages-blog-strapi-article-slug-tsx","path":"/blog/sekaictf-2023-wiki-game/","result":{"data":{"allStrapiArticle":{"nodes":[{"id":"3d0af543-77b4-52d5-815b-8be2cf2d6c0b","slug":"sekaictf-2023-wiki-game","title":"Sekai CTF 2023 - Wiki Game (PPC / 100P)","description":"Sekai CTF 2023 - organized by Project Sekai\nhttps://ctftime.org/event/1923/","content":{"data":{"content":"# Writeup\n\nThis is the first time that I found programming challenge in capture the flag competition ∑(O_O;)   \nFew years ago I played Kattis and Leetcode to prepare my first job interview. `Wiki Game` is `competitive programming` challenge like those. IMO, this challenge category is the most straight forward.\n\n## Challenge description\nHere is the <a href=\"https://www.cms.void-dojo.ninja/uploads/Wiki_Game_0281e6310a.pdf\" target=\"_blank\" alt=\"PDF\">challenge description</a> PDF file.\n     \n   \nChallenge author _sahuang_ illustrates what is Wiki Game - a game that asks players to start at a random wiki article page and navigate to the target article page by clicking the links within the article site with the fewest clicks. The remarkable thing is that, according to the Six Degrees of Wikipedia, players can almost always complete the game in 6 clicks. Here is the <a href=\"https://www.sixdegreesofwikipedia.com/?source=capture%20the%20flag&target=vtuber\" alt=\"wiki-game\">playground</a>.   \n\nI realized that this game must be related to Graph theory.   \nGraphs are data structures commonly used in various applications, such as computer networking. In fact, a network can be represented as a graph, with routers serving as nodes and routing protocols employing graph algorithms as building blocks. One of the main purposes of routing protocols is to determine the most efficient way for routers to communicate with each other, such as the Open Shortest Path First (OSPF) protocol.    \n\nIf you are a computer science student, you are likely familiar with these concepts. If not, you can think of your social relationships as a graph, where each person is a node (or vertex) and the connections between individuals represent edges.\n\nTo summarized, this program challenge asking us:\n- create a graph by parsing the input\n- input will give us `source` and `destination`, our program need to determine if any route the distance between `source` and `destination` within path length 6\n    - print \"YES\" if so, else \"NO\"\n- the program should be able to handle batch of questions\n- it is a directed graph, which means the link between nodes have direction. for example, input \"1 2\" means node1 can visit node2, but it doesn't mean node2 can visit node1. \n    - This is mention in challenge description PDF, section 5: In the second test case, there is no path from 0 to 9 so the answer is NO. There is a path\nof length 3 from 9 to 0, but the graph is directed so it does not count`\n\n## Input Handling\nInput handling is the first challenge to the beginner of competitive programing. To know more, you can check keyword `standard input output stream`. This challenge required our program to solving multiple batch of questions, the question size as known as _T_, where 1 <= _T_ <= 20.   \nHere is the sample input:   \n```bash:input\n2        # number of total cases\n7 6     # 1st case; vertices (nodes) = 7, edges = 6\n0 1     # describe the shape of graph, node0 -> node1\n1 2     # node1 -> node2\n2 3     # node2 -> node3\n3 4     # node3 -> node4\n4 5     # node4 -> node5\n5 6     # node5 -> node6\n0 6     # starting point = node0, destination point = node6\n10 7   # 2nd case, your code should do the similar input parsing\n0 1\n1 0\n0 2\n0 4\n1 8\n8 1\n9 8\n0 9\n```\nAnd we program the input handling part:   \n```py:input.py\nT = int(input().strip())  # Number of test cases\nfor _ in range(T):\n    n, m = map(int, input().strip().split())  # Number of vertices and edges\n    graph = defaultdict(list)  # if key have no value, fallback to [] empty list\n    for _ in range(m):\n        u, v = map(int, input().strip().split())  # Edge vertices\n        graph[u].append(v)  # Directed graph\n\n    src, dst = map(int, input().strip().split())  # Source and destination vertices\n```\n\n## Analyze\nHere we store our graph as dictionary of the list (or you may call it 2Darray generally).   \nThe index of graph dict represent the node. For example `graph[0]` have `[1, 2]` means node0's neighbor is node1 and node2.  \n\nWe can feed the test case in our program like this:\n```bash\ncat ./sample | python solver.py\n```\n\n\nYou can also visualize the graph by using this <a href=\"https://csacademy.com/app/graph_editor/\" alt=\"graph-editor\">online tool</a>.  \n  \n   \nSample 1 Graph:  \nsrc=node0, dst=node6   \nIt only have 1 path with length 6, luckily it fulfill the requirement path length <= 6, so print \"YES\". \n![sample1.png](https://www.cms.void-dojo.ninja/uploads/sample1_bd6b1a08c1.png)\n\nSample 2 Graph:  \nsrc=node0, dst=node9  \nSince the graph is directed graph, and node0 does not have a route that can visit node9, so print \"NO\".\n![sample1.png](https://www.cms.void-dojo.ninja/uploads/sample2_dcdc036654.png)\n\n\n## Approach\nOur target is find any one of the path that match path length <= 6 and reach our target destination, so once this criteria fulfill, the result is confirmed to be \"YES\" and our program should stop.   \nHere I use BFS (breath first search).  \nBFS is a strategy that searching target at the current depth prior to moving on to the nodes at the next depth.   \nIn simple words, BFS is like searching a maze by checking all the paths nearby before moving on to the paths that are farther way.   \n\nIt fit our requirement because our aim is not finding the deepest path, we are interest in any one of the path length is equal or below 6, in other words the shortest path to the target. So using BFS can return earlier. Another reason is there are no hardcore time limitation of this challenge, BFS is the most easy way to implement (* ^ ω ^)\n\n\n## Solve\n~~~python:solver.py\nfrom collections import defaultdict, deque\n\ndef bfs(graph, start, target):\n    visited = set()\n    queue = deque([(start, 0)])  # Stores vertices (aka node) along with their distance\n    while queue:\n        vertex, distance = queue.popleft()\n        if vertex == target and distance <= 6:  # If requirement is fulfill, early return \n            return True\n        if vertex not in visited:     # check if node is visited, prevent endless loop in cyclic graph\n            visited.add(vertex)\n            for neighbor in graph[vertex]:\n                queue.append((neighbor, distance + 1))\n    return False\n\n\ndef solve():\n    T = int(input().strip())  # Number of test cases\n    for _ in range(T):\n        n, m = map(int, input().strip().split())  # Number of vertices and edges\n        graph = defaultdict(list)\n        for _ in range(m):\n            u, v = map(int, input().strip().split())  # Edge vertices\n            graph[u].append(v)  # Directed graph\n\n        src, dst = map(int, input().strip().split())  # Source and destination vertices\n        result = bfs(graph, src, dst)\n        print(\"YES\" if result else \"NO\")\n\n\nif __name__ == \"__main__\":\n    solve()\n~~~\n\nSubmit the code to the online judge.    \nFinally we get the flag: `SEKAI{hyp3rL1nk_cha115_4r3_EZ}`   "}},"updatedAt":"2024-01-25T10:32:48.609Z","publishedAt":"2024-01-25T10:26:37.569Z","tags":[{"name":"python","color":"green"}],"categories":[{"name":"ctf","color":"red"}],"cover":{"formats":{"thumbnail":{"url":"/uploads/thumbnail_sekaictflogobanner_2095bffa1f.jpg"},"small":{"url":"/uploads/small_sekaictflogobanner_2095bffa1f.jpg"}}}}]}},"pageContext":{"id":"3d0af543-77b4-52d5-815b-8be2cf2d6c0b","slug":"sekaictf-2023-wiki-game","__params":{"slug":"sekaictf-2023-wiki-game"}}},"staticQueryHashes":["3001278788"],"slicesMap":{}}