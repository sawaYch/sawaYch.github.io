{"componentChunkName":"component---src-pages-blog-strapi-article-slug-tsx","path":"/blog/firebirdctf-2024-photo-encryptor/","result":{"data":{"allStrapiArticle":{"nodes":[{"id":"49db79d5-ed98-53c9-a045-ab7a05efd0cb","slug":"firebirdctf-2024-photo-encryptor","title":"Firebird CTF 2024 - Photo Encryptor (500pts)","description":"https://ash.firebird.sh/challenges?id=26\nhttp://ash-chal.firebird.sh:36026/","content":{"data":{"content":"![encrypted_flag.png](https://www.cms.void-dojo.ninja/uploads/encrypted_flag_b97fae797b.png)\n# Writeup\nSee the image above? A secret flag is hidden withinðŸ¤¯     \nPersonally I think this one is mixing reverse with kind of crypto category.\nAuthor give us a encrypted flag image; a website which perform encryption process; and the source code of encryption logic (Python flask).    \n\n## Solving steps\n### Replicate scenario locally\nThis step is important which make me easier to do experiment.   \nGiven the encryption soruce code:\n```python\n@app.route('/', methods=['GET', 'POST'])\ndef home():\n    if request.method == 'GET':\n        return render_template('index.html', msg='', image_b64='')\n    \n    image = request.files['file']\n    im = Image.open(image)\n    pix = im.load()\n    width, height = im.size\n\n    if (width > 720) or (height > 405):\n        return render_template('index.html', msg='The image is too large!', image_b64='')\n\n    if (im.format != 'PNG'):\n        return render_template('index.html', msg='You can only upload an PNG image!', image_b64='')\n\n    key = '<**CENSORED**>'\n\n    seed(hashlib.md5(key.encode()).hexdigest().encode())\n    \n    for x in range(width):\n        for y in range(height):\n            pix[x, y] = (pix[x, y][0] ^ pix[(x+randint(0, width))%width, (y+randint(0, height))%height][0],\n                        pix[x, y][1] ^ pix[(x+randint(0, width))%width, (y+randint(0, height))%height][1],\n                        pix[x, y][2] ^ pix[(x+randint(0, width))%width, (y+randint(0, height))%height][2])\n    \n    for x in range(width):\n        for y in range(height):\n            pix[x, y] = (pix[x, y][0] ^ ord(key[(x+y)%len(key)]), \n                        pix[x, y][1] ^ ord(key[(x+y)%len(key)]),\n                        pix[x, y][2] ^ ord(key[(x+y)%len(key)]))\n    \n    imgByteArr = io.BytesIO()\n    im.save(imgByteArr, format='png')\n    encoded_img_data = base64.b64encode(imgByteArr.getvalue())\n\n    return render_template(\"index.html\", msg='Your image has been encrypted!', image_b64=encoded_img_data.decode('utf-8'))\n```\nWe can take the core encryption logic out, convert it into a local python program:\n```python\nimport hashlib\nfrom random import *\nfrom PIL import Image\nimport base64\nimport io\n\n# @app.route('/', methods=['GET', 'POST'])\ndef home():\n    # if request.method == 'GET':\n    #     return render_template('index.html', msg='', image_b64='')\n    im = Image.open(r\"./zero.png\")\n    pix = im.load()\n    width, height = im.size\n\n    if (width > 720) or (height > 405):\n        return print('The image is too large!')\n\n    if (im.format != 'PNG'):\n        return print('You can only upload an PNG image!')\n\n    key = \"{***censored***}\"\n\n    seed(hashlib.md5(key.encode()).hexdigest().encode())\n    \n    # w=720, h=405\n    # pix[0,0]   returns RGB (98, 152, 199)\n    # pick 'R', 98, do xor\n    # pix[(0+?) % width, (0+?) % height] \n        \n    for x in range(width):\n        for y in range(height):\n            print(x,y, ' => ', (x+randint(0, width))%width, (y+randint(0, height))%height)\n            pix[x, y] = (pix[x, y][0] ^ pix[(x+randint(0, width))%width, (y+randint(0, height))%height][0],\n                        pix[x, y][1] ^ pix[(x+randint(0, width))%width, (y+randint(0, height))%height][1],\n                        pix[x, y][2] ^ pix[(x+randint(0, width))%width, (y+randint(0, height))%height][2])\n    for x in range(width):\n        for y in range(height):\n            pix[x, y] = (pix[x, y][0] ^ ord(key[(x+y)%len(key)]), \n                        pix[x, y][1] ^ ord(key[(x+y)%len(key)]),\n                        pix[x, y][2] ^ ord(key[(x+y)%len(key)]))\n    \n    imgByteArr = io.BytesIO()\n    im.save(imgByteArr, format='png')\n    encoded_img_data = base64.b64encode(imgByteArr.getvalue())\n    img = Image.open(io.BytesIO(base64.b64decode(encoded_img_data)))\n    img.save('encrypted_zero.png', 'PNG')\n\nif __name__ == \"__main__\":\n    home()\n```\n### Leak the key\nWe know nothing about the key? NO, parts of the key is attached into the encryption result image's RGB. We can use a all black image, i.e. every pixel is RGB(0,0,0) to leak the key. Here I named it as `zero.png`.  Noted that this image width height must align to the encrypted flag image, which width = 720, height = 405. `zero.png` can be generate using following:   \n```python\nfrom PIL import Image\nwidth = 720\nheight = 405\nimage = Image.new('RGB', (width, height))\nimage.save(\"zero.png\", \"PNG\")\n```\nSubmit `zero.png` to the challenge website, we get `encrypted_zero.png`. Wow....it really surprise me what a patternðŸ¤¯\n![encrypted_zero.png](https://www.cms.void-dojo.ninja/uploads/encrypted_zero_ef1c66fbeb.png)\n\n### Analyst encryption\nThe encryption function consist 2 parts:\n1. each x, y pixel's R, G, B will do xor calculation to the random pixel's corresponding R, G, B\n2. each x, y pixel's R, G, B will do xor calculation to `key[ (x+y) % len(key) ]`\n\n\nPart 2 consist critical weakness, which cause attacker can leak the key just by doing the reverse process of XOR, and luckily this part has no standalone to part 1. We will discuss encryption part 1 later.   \nFrom source code of encryption function part 2 , we know that encryption function:\n```text\nencrypt(plaintext) => plaintext xor key[some_index]\n```\nand decryption function will be:\n```text\ndecrypt(cipher) => cipher xor key[some_index]\n```\nHence, we can leak the key by:\n```text\nleakKey(cipher, plaintext) => cipher xor plaintext\n```\nI write this to leak the key. Since I don't know the length of the key, just set the key length corresponding to image height * width. Key pattern will keep repeating eventually! That's one of the tricky one!\n```python:leakKey.py\nfrom random import *\nfrom PIL import Image\n\ndef leakKey():\n    im = Image.open(r\"./encrypted_zero.png\")\n    origin=Image.open(r\"./zero.png\")\n    pix = im.load()\n    ori = origin.load()\n    (width,height) = im.size\n    print('width-height', width, height)\n\n    key = ['INIT'] * (720+405)\n\n    # do reverse process\n    for x in range(width):\n        for y in range(height):\n            part_of_key = pix[x, y][0] ^  ori[x,y][0]\n            key[x+y] = chr(part_of_key)\n    join_key = ''.join(key)\n    print('key', join_key)\n\n    \nif __name__ == \"__main__\":\n    leakKey()\n    \n# output\n# firebird_is_the_best!!UwUfirebird_is_the_best!!UwUfirebird_is_the_best!!UwUfirebird_is_the_best!!UwU...(repeating)\n```\nkey: `firebird_is_the_best!!UwU`\n\n### Decryption\nNoted that the most tricky one is to deal with the random stuffs of encryption function part 1. I stuck at here and spent much longer time than I expected.   \nGiven the random seed is based on the key, this part is fine, we already done this part because we have the key.\nPay attenstion to these 2 points:\n1. The execution order for decryption need to be reversed, i.e. for encrypt is `for x in 0...width`; for decrypt you need to `for x in width...0`.\n2. The random generated pixel x, y offset need to maintain in order by using a table. Otherwise the decryption start with last pixel, and program is generating the first random number for pixel offset, then whole calculation will be wrong, because the last pixel should use last generated random number.\nSee the code below then you will understand what I meanðŸ˜‚    \nFeed the encryped flag image to the decryption program, if everything work well we can get the flag image!   \n```python:decrypt.py\nimport hashlib\nfrom random import *\nfrom PIL import Image\nimport base64\nimport io\n\n\ndef decrypt():\n    im = Image.open(r\"./encrypted_flag.png\")\n    pix = im.load()\n    width, height = im.size\n\n    key = 'firebird_is_the_best!!UwU'\n\n    seed(hashlib.md5(key.encode()).hexdigest().encode())\n\n    for x in reversed(range(width)):\n        for y in reversed(range(height)):\n            pix[x, y] = (pix[x, y][0] ^ ord(key[(x+y)%len(key)]), \n                        pix[x, y][1] ^ ord(key[(x+y)%len(key)]),\n                        pix[x, y][2] ^ ord(key[(x+y)%len(key)]))\n   \n    mem = [[0 for _ in range(height)] for _ in range(width)]\n\n    # retrieve back the damn random position\n    for x in range(width):\n        for y in range(height):\n            mem[x][y] = [\n                ((x+randint(0, width))%width, (y+randint(0, height))%height), \n                ((x+randint(0, width))%width, (y+randint(0, height))%height), \n                ((x+randint(0, width))%width, (y+randint(0, height))%height)\n            ]\n\n    for x in reversed(range(width)):\n          for y in reversed(range(height)):\n              pix[x, y] = (pix[x, y][0] ^ pix[mem[x][y][0][0], mem[x][y][0][1]][0],\n                          pix[x, y][1] ^ pix[mem[x][y][1][0], mem[x][y][1][1]][1],\n                          pix[x, y][2] ^ pix[mem[x][y][2][0], mem[x][y][2][1]][2])\n\n    imgByteArr = io.BytesIO()\n    im.save(imgByteArr, format='png')\n    encoded_img_data = base64.b64encode(imgByteArr.getvalue())\n    img = Image.open(io.BytesIO(base64.b64decode(encoded_img_data)))\n    img.save('decrypted_flag.png', 'PNG')\n    img.show()\n\nif __name__ == \"__main__\":\n    decrypt()\n```\n\n# Done!\n![decrypted_flag.png](https://www.cms.void-dojo.ninja/uploads/decrypted_flag_1e66cc916d.png)\n\nflag: `firebird{7h1s_t1m3_rea11y_sh0u1d_n07_be_cla551f1ed_as_a_cryp70_cha113ng3_la??r1gh7?}`"}},"updatedAt":"2024-02-13T22:51:54.769Z","publishedAt":"2024-02-13T21:08:27.830Z","tags":[{"name":"firebirdctf","color":"red"},{"name":"reverse","color":"orange"},{"name":"python","color":"green"}],"categories":[],"cover":{"formats":{"thumbnail":{"url":"/uploads/thumbnail_firebirdctf_2024_4c8f24745f.png"},"small":null}}}]}},"pageContext":{"id":"49db79d5-ed98-53c9-a045-ab7a05efd0cb","slug":"firebirdctf-2024-photo-encryptor","__params":{"slug":"firebirdctf-2024-photo-encryptor"}}},"staticQueryHashes":["3001278788"],"slicesMap":{}}